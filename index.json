[{"content":"Let\u0026rsquo;s say you want to represent a 3 * 3 matrix using an array in C. Here are some fashions that you can apply: Static 2D Array Create Array: int arr[3][3] = { {0, 1, 0}, {0, 0, 1}, {0, 1, 0} }; Traverse Array: for (int i = 0; i \u0026lt; 3; i++) { for (int j = 0; j \u0026lt; 3; j++) { printf(\u0026#34;%d \u0026#34;, arr[i][j]); } printf(\u0026#34;\\n\u0026#34;); } Free Array: // No need to worry about, as it\u0026#39;s created on the stack. Pros:\nEasy to initialize and use. No dynamic memory allocation required. Cons:\nLimited by stack size (usually signaficantly smaller than heap), not suitable for large arrays. Fixed size, less flexible for varying data. Jagged 2D Array (Dynamic) Create Array: int cols = 3, rows = 3; int **arr; arr = (int **)malloc(rows * sizeof(int*)); for (int i = 0; i \u0026lt; rows; i++){ arr[i] = (int *)malloc(cols * sizeof(int)); } Traverse Array: for (int i = 0; i \u0026lt; rows; i++) { for (int j = 0; j \u0026lt; cols; j++) { printf(\u0026#34;%d \u0026#34;, arr[i][j]); } printf(\u0026#34;\\n\u0026#34;); } Free Array: for (int i = 0; i \u0026lt; rows; i++) { free(arr[i]); } free(arr); Pros:\nFlexible sizes for each row. Suitable for complex data structures (like where the size of each row is not uniform). Cons:\nRequires careful memory management. Jagged 2D array is not stored contiguously in memory, so it has cache locality issues if you care about performance. VLA Dynamic 2D Array Create Array: int rows = 3, cols = 3; int (*arr)[cols] = malloc(rows * sizeof(*arr)); Traverse Array: for (int i = 0; i \u0026lt; rows; i++) { for (int j = 0; j \u0026lt; cols; j++) { printf(\u0026#34;%d \u0026#34;, arr[i][j]); } printf(\u0026#34;\\n\u0026#34;); } Free Array: free(arr); Pros: Allows dynamic allocation with variable sizes at runtime. Easier to handle than a jagged array. Cons: Not supported in all C standards. (VLA is a feature after C99). 1D Array Simulation Create Array: int rows = 3, cols = 3; int *arr = malloc(rows * cols * sizeof(int)); Traverse Array: for (int i = 0; i \u0026lt; rows; i++) { for (int j = 0; j \u0026lt; cols; j++) { printf(\u0026#34;%d \u0026#34;, arr[i * cols + j]); } printf(\u0026#34;\\n\u0026#34;); } Free Array: free(arr); Pros: Simulates 2D arrays with simple memory management. Flexible for dynamic size adjustments. Cons: Accessing elements can be less intuitive. Reference: CppReference: C99 variable length arrays ","permalink":"https://jrmh.dev/posts/2d_array_c/","summary":"Let\u0026rsquo;s say you want to represent a 3 * 3 matrix using an array in C. Here are some fashions that you can apply: Static 2D Array Create Array: int arr[3][3] = { {0, 1, 0}, {0, 0, 1}, {0, 1, 0} }; Traverse Array: for (int i = 0; i \u0026lt; 3; i++) { for (int j = 0; j \u0026lt; 3; j++) { printf(\u0026#34;%d \u0026#34;, arr[i][j]); } printf(\u0026#34;\\n\u0026#34;); } Free Array: // No need to worry about, as it\u0026#39;s created on the stack.","title":"2D Arrays in C"},{"content":"Before Starting: basic understanding of memory address \u0026amp; pointers in C: https://www.w3schools.com/c/c_memory_address.php https://www.w3schools.com/c/c_pointers.php 2D arrays in C an online IDE with compiler that might come in handy: jdoodle C What\u0026rsquo;s the Issue? Let\u0026rsquo;s understand the problem first, here\u0026rsquo;s a C code snippet with bugs.\n#include\u0026lt;stdio.h\u0026gt; void traverse(int **matrix, size_t row_len, size_t col_len){ for (int i = 0; i \u0026lt; row_len; i++){ for (int j = 0; j \u0026lt; col_len; j++){ printf(\u0026#34;%d \u0026#34;, matrix[i][j]); } printf(\u0026#34;\\n\u0026#34;); } } int main(void) { int matrix[3][3] = { {0, 1, 0}, {0, 0, 1}, {0, 1, 0} }; traverse(matrix, 3, 3); } Simply copy and paste and run it. Most likely you will see Command terminated by signal 11.\nWhy SIGSEGV Happens? Now let\u0026rsquo;s break down these different kinds of \u0026ldquo;pointers\u0026rdquo; in C to understand the problem:\nA Normal Pointer (like int*): int* ptr: A pointer in C is a variable that holds the memory address of another variable. Size of a pointer jump: ptr++ in int *ptr moves the pointer by sizeof(int) bytes. Array Name: int arr[5]: in this case arr is not exactly a 100% pointer. As this \u0026ldquo;pointer\u0026rdquo; does not allow the increment operation (++). This is because arrays are not modifiable l-values in C. However, you can use a new pointer int* ptr = arr as in C, the name of an array can be used as a pointer to its first element. Size of a pointer jump: ptr++ in this case moves the pointer by sizeof(int) bytes; And if it\u0026rsquo;s a 2D array int arr[5][5]: Then the first element is an int[5] array, so a pointerizion in this case should be: int (*ptr)[5] = arr. Size of a pointer jump: ptr++ in this case moves the pointer by 5 * sizeof(int) bytes. A Pointer to Pointer: int ** ptr: A pointer to pointer in C is a variable that holds the memory address of another pointer. Size of a pointer jump: ptr++ in int **ptr moves the pointer by sizeof(int*) bytes aka a poniter\u0026rsquo;s size. So The function traverse is expecting a parameter of type int**, (a pointer to a pointer to an int). This is different from int (*)[3] in terms of memory layout and how the pointer arithmetic works.\nPlease run the following code:\n#include\u0026lt;stdio.h\u0026gt; int main(void) { int matrix[3][3] = { {0, 1, 0}, {0, 0, 1}, {0, 1, 0} }; int **ptr1 = matrix; int (*ptr2)[3] = matrix; printf(\u0026#34;ptr1: %p\\n\u0026#34;, ptr1); printf(\u0026#34;ptr2: %p\\n\u0026#34;, ptr2); printf(\u0026#34;*ptr1: %p\\n\u0026#34;, *ptr1); printf(\u0026#34;*ptr2: %p\\n\u0026#34;, *ptr2); return 0; } You can get the output like:\nptr1: 0x7ffe5261a090 ptr2: 0x7ffe5261a090 *ptr1: 0x100000000 *ptr2: 0x7ffe5261a090 Your ptr1, ptr2,and *ptr2 might be different than mine (as we run on different machine) but the third line *ptr1: 0x100000000 should be the same and it doesn\u0026rsquo;t looks like an actual address at all.\nWhen you dereference ptr1 using *ptr1, you\u0026rsquo;re treating the value at matrix[0][0] as a pointer (since ptr1 is an int**). This is why you get a strange and seemingly unrelated memory address 0x100000000. It\u0026rsquo;s interpreting the integer value at matrix[0][0] as a memory address.\nPlease notice that operation like int **ptr1 = matrix; is actually problematic and should not compile without a warning or error in standard C. These are not compatible types. If your compiler allows this assignment, it\u0026rsquo;s doing so without proper type checking, that is unsafe.\nWhat\u0026rsquo;s the Solutions? If your compiler supports variable length arrays (VLA) then you can declare the traverse function like:\n#include \u0026lt;stdio.h\u0026gt; void traverse(size_t row_len, size_t col_len, int matrix[row_len][col_len]){ for (size_t i = 0; i \u0026lt; row_len; i++) { for (size_t j = 0; j \u0026lt; col_len; j++) { printf(\u0026#34;%d \u0026#34;, matrix[i][j]); } printf(\u0026#34;\\n\u0026#34;); } } int main(void) { int matrix[3][3] = { {0, 1, 0}, {0, 0, 1}, {0, 1, 0} }; printf(\u0026#34;matrix first value outside func %d\\n\u0026#34;, matrix[0][0]); traverse(3, 3, matrix); } This is a cleaner and more straightforward way of handling arrays of varying sizes in C, provided that the compiler supports C99 or later standards.\n","permalink":"https://jrmh.dev/posts/md_arrays_in_c/","summary":"Before Starting: basic understanding of memory address \u0026amp; pointers in C: https://www.w3schools.com/c/c_memory_address.php https://www.w3schools.com/c/c_pointers.php 2D arrays in C an online IDE with compiler that might come in handy: jdoodle C What\u0026rsquo;s the Issue? Let\u0026rsquo;s understand the problem first, here\u0026rsquo;s a C code snippet with bugs.\n#include\u0026lt;stdio.h\u0026gt; void traverse(int **matrix, size_t row_len, size_t col_len){ for (int i = 0; i \u0026lt; row_len; i++){ for (int j = 0; j \u0026lt; col_len; j++){ printf(\u0026#34;%d \u0026#34;, matrix[i][j]); } printf(\u0026#34;\\n\u0026#34;); } } int main(void) { int matrix[3][3] = { {0, 1, 0}, {0, 0, 1}, {0, 1, 0} }; traverse(matrix, 3, 3); } Simply copy and paste and run it.","title":"2D Arrays and Pointers in C"},{"content":"In Linux, these concepts are foundational: You will see lots of faces in the list (like Mounts, Processes, \u0026hellip;) while using containerization tools like Docker. Processes: These are running instances of programs. Linux manages them, allocating resources and scheduling their execution. Mounts: This refers to attaching a file system to a directory, enabling access to files in storage. chroot/pivot_root: These are methods to change the root directory. chroot changes the perceived root directory for a process, while pivot_root is used in system initialization, replacing the old root with a new one. CoW Storage (Copy-on-Write): A resource-management technique where system resources are shared and copied only when modified, optimizing performance and memory usage. Users: In Linux, users are entities with permissions to access and manipulate files and processes. Each user has a unique ID. Namespaces: These are used to isolate processes, ensuring they only see certain system resources. They\u0026rsquo;re key in containerization, allowing safe and secure multitasking. Memory Management: Linux efficiently manages memory through techniques like paging and swapping, ensuring optimal use of RAM and storage resources for process execution. For More Details:\nLinux Primitives Slides (Credits and Acknowlegement: Nati Cohen, Avishai Ish-Shalom) The Linux Kernel Documentation Linux man page ","permalink":"https://jrmh.dev/posts/linux_primitives/","summary":"In Linux, these concepts are foundational: You will see lots of faces in the list (like Mounts, Processes, \u0026hellip;) while using containerization tools like Docker. Processes: These are running instances of programs. Linux manages them, allocating resources and scheduling their execution. Mounts: This refers to attaching a file system to a directory, enabling access to files in storage. chroot/pivot_root: These are methods to change the root directory. chroot changes the perceived root directory for a process, while pivot_root is used in system initialization, replacing the old root with a new one.","title":"Linux Primitives"},{"content":"Introduction In our interconnected digital age, it\u0026rsquo;s crucial to access our devices securely from any location. This guide will walk you through setting up a VPN with Tailscale, facilitating a seamless and secure connection between an Ubuntu desktop (acting as the server) and a MacBook.\nFor those in a hurry, jump straight to the instructions. If you\u0026rsquo;re curious, here are some Q\u0026amp;As:\nWhat is SSH? How does SSH help us develop remotely? What is a VPN? Why use SSH and VPN in combination? Setting this up might seem daunting, so I use Tailscale to make my life easier.\nInstall Tailscale First, install Tailscale on both your SSH server and client. MacBook users take note: There are three methods to run Tailscale on macOS. For an enhanced user experience, please install the open-source Tailscale \u0026amp; Tailscaled CLI version. The GUI version, unfortunately, doesn\u0026rsquo;t operate in the background.\nAll the installation instructions can be found here.\nConnect Your Devices and Set Up Tailscale SSH After installation, connecting your devices is straightforward. Just follow the on-screen instructions.\nThis guide uses Tailscale\u0026rsquo;s SSH service for the connection, which is both user-friendly and secure. Dive deeper into the nuances of Tailscale SSH.\nHowever, if you prefer, you can use the OpenSSH Server and client paired with the Tailscale VPN instead of Tailscale\u0026rsquo;s SSH service. This approach is slightly trickier to configure securely.\nOn Ubuntu:\nsudo tailscale up --ssh On Mac (with the Tailscale CLI version):\ntailscale up Once you\u0026rsquo;ve linked the devices, you\u0026rsquo;ll see an output resembling the following: The IP address is auto-allocated by Tailscale once your device gets connected. (and for sure it’s not 127.0.0.1 Lol)\nConnect Your Devices in IDE Once you get there, in your client device terminal, use the below command to connect:\nssh \u0026lt;username\u0026gt;@\u0026lt;server device vpn ip adress\u0026gt; Replace \u0026lt;username\u0026gt; with a valid user from your SSH server system.\nIf you\u0026rsquo;ve managed to connect successfully using SSH, you might want to set up an SSH connection within your favorite IDE for a smoother remote development experience. Personally, I use vscode, and you can find setup instructions here.\nHere\u0026rsquo;s a glimpse of the vscode SSH connection terminal on my laptop:\n","permalink":"https://jrmh.dev/posts/ssh_tailscale/","summary":"Introduction In our interconnected digital age, it\u0026rsquo;s crucial to access our devices securely from any location. This guide will walk you through setting up a VPN with Tailscale, facilitating a seamless and secure connection between an Ubuntu desktop (acting as the server) and a MacBook.\nFor those in a hurry, jump straight to the instructions. If you\u0026rsquo;re curious, here are some Q\u0026amp;As:\nWhat is SSH? How does SSH help us develop remotely?","title":"Secure and Low-latency SSH Connection: Setting Up via Tailscale"},{"content":"What is awk? awk is a powerful scripting language and command-line utility for text-processing in Unix/Linux environments. It scans each line of a file, looking for patterns that match, and then processes the line accordingly (kinda like reduce in JavaScript but has difference). It\u0026rsquo;s excellent for manipulating structured text data like CSV, logs, or even simple text files.\nBasic Syntax The basic syntax of awk is:\nawk \u0026#39;pattern {action}\u0026#39; file pattern: A condition to match (like regex or conditional expressions). If omitted, awk processes all lines. action: Commands to execute when a pattern matches. Actions are enclosed in {}. Types of Patterns in awk Regular Expressions: Use regular expressions as patterns to match lines. Example: awk '/error/ {print}' file.txt prints lines containing \u0026ldquo;error\u0026rdquo;.\nRelational Expressions: These include comparisons of numbers or strings. Example: awk '$2 \u0026gt; 100 {print}' file.txt prints lines where the second field is greater than 100.\nCompound Patterns: Combine patterns using logical operators (\u0026amp;\u0026amp;, ||, !). Example: awk '$1 == \u0026quot;start\u0026quot; \u0026amp;\u0026amp; $3 \u0026gt; 50 {print}' file.txt prints lines where the first field is \u0026ldquo;start\u0026rdquo; and the third field is over 50.\nRange Patterns: Match lines from the start pattern to the end pattern. Example: awk '/start/, /end/ {print}' file.txt prints lines from \u0026ldquo;start\u0026rdquo; to \u0026ldquo;end\u0026rdquo;.\nSpecial Patterns BEGIN and END: BEGIN: Executed before reading any input lines, often for initialization. END: Executed after all lines are processed, used for summaries or conclusions.\nExample Problem: Word Frequency Let\u0026rsquo;s use LeetCode 192. Word Frequency: write a bash script to calculate the frequency of each word in a text file words.txt as a example.\nThe solution of this problem is straight forward, bascially in 3 steps:\nRead the file words.txt; Walk through each word, record/update the frequencey; Sort and print out the result. However, implementing this in a shell script can be hard, especially for people who aren\u0026rsquo;t familiar with Linux Shell Script. It\u0026rsquo;s even more challenging if you want to write it in a single line of script code (and yeah all Linux developers do it cause it looks cool af XD)\nBut no worries, let\u0026rsquo;s break the damn thing down with Shell Pipe. If you don\u0026rsquo;t know what it is, I have another blog about that and feel free to check it out.\nSolution: Read the File cat words.txt\nThis command reads the content of the file words.txt. cat is short for concatenate. When used with a file name, it displays the content of the file.\necho -e $(...)\nThe $(...) is command substitution, which means it executes the command inside the parentheses and then echo outputs the result. echo -e enables interpretation of backslash escapes. When used with the output of cat words.txt, it converts newlines into spaces. This effectively puts all the words on a single line.\nUpdate frequencey This awk script is the core part of the command.\nfor(i=1; i\u0026lt;=NF; i++){words[$i]++}: This loop iterates over all fields (words) in a line. NF is a built-in variable in awk that represents the number of fields in the current record (line). For each word, it increments the count in the associative array words.\nEND {for(w in words) print w, words[w]}: After processing all lines, this part executes. It iterates through each index (word) in the array words and prints the word and its frequency.\nSort and Print sort -k2 -n -r\nThis sorts the output from the awk command. -k2 tells sort to sort based on the second column (which is the word frequency). -n means to sort numerically (since word counts are numbers). -r sorts in reverse order, so you get a list from the most frequent to the least frequent word.\necho -e $(cat words.txt) | awk \u0026#39;{for(i=1; i\u0026lt;=NF; i++){words[$i]++}} END {for(w in words) print w, words[w]}\u0026#39; | sort -k2 -n -r ","permalink":"https://jrmh.dev/posts/bash_awk/","summary":"What is awk? awk is a powerful scripting language and command-line utility for text-processing in Unix/Linux environments. It scans each line of a file, looking for patterns that match, and then processes the line accordingly (kinda like reduce in JavaScript but has difference). It\u0026rsquo;s excellent for manipulating structured text data like CSV, logs, or even simple text files.\nBasic Syntax The basic syntax of awk is:\nawk \u0026#39;pattern {action}\u0026#39; file pattern: A condition to match (like regex or conditional expressions).","title":"Understand awk in Linux Shell"},{"content":"Shell pipes are a powerful feature of command-line interfaces in Unix and Unix-like systems, including Linux and macOS. They allow you to pass the output of one command directly into another command, creating a \u0026ldquo;pipeline\u0026rdquo; of operations. This can greatly simplify your tasks and enable efficient data processing. In this post, we\u0026rsquo;ll explore the basics of shell pipes and see some practical examples.\nWhat is a Shell Pipe? A shell pipe, denoted by the | symbol, takes the output (stdout) of one command and uses it as the input (stdin) for the next command. This chaining of commands allows you to perform complex tasks with a combination of simple commands.\nBasic Example of Using a Pipe Consider a situation where you have a file named names.txt containing a list of names, and you want to find out how many names are in the file. You can use a combination of cat, grep, and wc commands:\ncat names.txt | grep -v \u0026#34;^#\u0026#34; | wc -l In this command:\ncat names.txt displays the content of names.txt. grep -v \u0026quot;^#\u0026quot; filters out lines starting with # (comments, for instance). wc -l counts the number of lines. The pipe | passes the output of each command to the next. Pipes are particularly useful for sorting and filtering data. For example, if you want to list all files in the current directory, sorted by file size:\nls -l | sort -nk5 This command:\nls -l lists files in long format. sort -nk5 sorts the output numerically (-n) based on the fifth column (-k5), which is the file size. You can also chain multiple pipes together. Suppose you want to check the most used words in a text file:\ncat article.txt | tr \u0026#39; \u0026#39; \u0026#39;\\n\u0026#39; | sort | uniq -c | sort -nr | head -10 This breaks down as:\ncat article.txt displays the file content. tr ' ' '\\n' replaces spaces with new lines, putting each word on a separate line. sort sorts the words alphabetically. uniq -c counts the occurrences of each word. sort -nr sorts the word count in descending order. head -10 shows the top 10 results. Conclusion Shell pipes are a simple yet powerful tool for processing and manipulating data on the command line. By understanding and using pipes, you can combine basic commands to perform complex tasks efficiently.\n","permalink":"https://jrmh.dev/posts/bash_pipe/","summary":"Shell pipes are a powerful feature of command-line interfaces in Unix and Unix-like systems, including Linux and macOS. They allow you to pass the output of one command directly into another command, creating a \u0026ldquo;pipeline\u0026rdquo; of operations. This can greatly simplify your tasks and enable efficient data processing. In this post, we\u0026rsquo;ll explore the basics of shell pipes and see some practical examples.\nWhat is a Shell Pipe? A shell pipe, denoted by the | symbol, takes the output (stdout) of one command and uses it as the input (stdin) for the next command.","title":"Shell Pipes: Simplifying Command Line Tasks"},{"content":" A Self-learning Guide for Computer Science: csdiy.wiki freeCodeCamp TBC\u0026hellip; ","permalink":"https://jrmh.dev/editors-picks/cs_self_study/","summary":" A Self-learning Guide for Computer Science: csdiy.wiki freeCodeCamp TBC\u0026hellip; ","title":"CS Self-Study Guides for Reference"},{"content":" What is Dependency Injection? TBC\u0026hellip; ","permalink":"https://jrmh.dev/editors-picks/design_pattern/","summary":" What is Dependency Injection? TBC\u0026hellip; ","title":"Design Pattern"},{"content":" Docker for Beginners Docker 入门教程 TBC ","permalink":"https://jrmh.dev/editors-picks/docker/","summary":" Docker for Beginners Docker 入门教程 TBC ","title":"Docker"},{"content":" Java Roadmap for 2024 by Nelson TBC\u0026hellip; ","permalink":"https://jrmh.dev/editors-picks/java/","summary":" Java Roadmap for 2024 by Nelson TBC\u0026hellip; ","title":"Java"}]